syntax = "proto3";

package fluid.controlplane.v1;

import "google/protobuf/timestamp.proto";
import "std/v1/std.proto";

option go_package = "github.com/liquidspill/proto/go/fluid/controlplane/v1;controlplanev1";

service ControlPlaneService {
  rpc Control(ControlMessageRequest) returns (ControlMessageResponse) {}
}

message ControlMessageRequest {
  ControlMessage message = 1;
}

message ControlMessageResponse {
  ControlMessage message = 1;
}

// Control messages sent by the server. For each of them, since
// we don't expect them to be changed often, we just send the
// entire configuration on each change (for the given message)
message ControlMessage {
  oneof message {
    Telemetry telemetry = 1;
    Devices devices = 2;
  }
}

// Telemtry control messages
message Telemetry {
  // Whether or not to export telemetry data. This can be
  // switched off to prevent data from being written to
  // the catalogue and to blob storage.
  bool export = 1;
}

// Device control messages
message Devices {
  oneof device {
    // Generic device that sends flow data. All devices are generic
    // devices, however in future we will support more specific dimensions
    // from supported models
    GenericDevice generic = 1;
  }
}

message GenericDevice {
  repeated GenericDeviceDescriptor devices = 1;
}

message GenericDeviceDescriptor {
  // User-defined name for the device
  string name = 1;
  // Description of the device
  string description = 2;

  string vendor = 3;
  string model = 4;

  // The IP addresses of the device. We use these to look
  // up the relevant device to enrich our flow with its information.
  repeated IpAddress addresses = 5;
  // User-defined labels for the device. Used to add more metadata
  // to query over.
  repeated std.v1.KeyValue labels = 6;
}

message IpAddress {
  bytes address = 1;
  IPVersion version = 2;
}

enum IPVersion {
  IPVERSION_UNSPECIFIED = 0;
  IPVERSION_IPV4 = 1;
  IPVERSION_IPV6 = 2;
}
