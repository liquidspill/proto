syntax = "proto3";

package nexus.controlplane.v1;

import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "std/v1/std.proto";

option go_package = "github.com/liquidspill/proto/go/nexus/controlplane/v1;controlplanev1";

// The control plane service manages all operational aspects of the system. This includes
// owning the management of clusters, devices, queries, etc. Additionally, it manages the
// lifecycle of our agents.
service ControlPlaneService {
  // Dataset management
  rpc CreateDataset(CreateDatasetRequest) returns (CreateDatasetResponse) {}
  rpc DeleteDataset(DeleteDatasetRequest) returns (DeleteDatasetResponse) {}
  rpc ListDatasets(ListDatasetsRequest) returns (ListDatasetsResponse) {}
  rpc GetDataset(GetDatasetRequest) returns (GetDatasetResponse) {}

  // Cluster management
  rpc CreateCluster(CreateClusterRequest) returns (CreateClusterResponse) {}
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {}
  rpc GetCluster(GetClusterRequest) returns (GetClusterResponse) {}

  // Device management
  rpc CreateDevice(CreateDeviceRequest) returns (CreateDeviceResponse) {}
  rpc DeleteDevice(DeleteDeviceRequest) returns (DeleteDeviceResponse) {}
  rpc UpdateDevice(UpdateDeviceRequest) returns (UpdateDeviceResponse) {}
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse) {}
  rpc GetDevice(GetDeviceRequest) returns (GetDeviceResponse) {}

  // Query management
  rpc CreateQuery(CreateQueryRequest) returns (CreateQueryResponse) {}
  // Starts the execution of a given query (nexus -> fluid)
  rpc SubmitQueryExecution(SubmitQueryExecutionRequest) returns (SubmitQueryExecutionResponse) {}
  // Registers updates of a query (fluid -> nexus)
  rpc UpdateQueryExecution(UpdateQueryExecutionRequest) returns (UpdateQueryExecutionResponse) {}
  // Poll the query execution job. Used by the client to get the status of
  // a query. If it is complete, the result will be returned alongside it.
  rpc PollQueryExecution(PollQueryExecutionRequest) returns (PollQueryExecutionResponse) {}


  // Agent lifecycle
  // rpc Bootstrap(BootstrapRequest) returns (BootstrapResponse) {}

  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}
  // Add a stop agent request which can hit a service running in the
  // agent that will cause it to quit
  // Add a update config request
}

//===== DATASETS =====//

message Dataset {
  string pid = 1;
  string team_pid = 2;
  string name = 3;
  optional string description = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

message CreateDatasetRequest {
  string team_pid = 1;
  string name = 2;
  optional string description = 3;
}

message CreateDatasetResponse {
  string pid = 1;
  Dataset dataset = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteDatasetRequest {
  string pid = 1;
}

message DeleteDatasetResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message ListDatasetsRequest {
  string team_pid = 1;
}

message ListDatasetsResponse {
  string team_pid = 1;
  repeated Dataset datasets = 2;
}

message GetDatasetRequest {
  string pid = 1;
}

message GetDatasetResponse {
  string pid = 1;
  Dataset dataset = 2;
}

//===== CLUSTERS =====//

// Cluster represents the query/read side of the system
// where a distributed query engine runs to query manifests
// and calculate final results. Clusters can be either
// BYOC (bring your own cloud) or serverless (managed in our cloud).
message Cluster {
  string pid = 1;
  string team_pid = 2;
  string name = 3;
  ClusterType type = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

enum ClusterType {
  CLUSTER_TYPE_UNSPECIFIED = 0;
  // The cluster runs in their own cloud
  CLUSTER_TYPE_BYOC = 1;
  // We run the cluster in our cloud, on behalf of the user
  CLUSTER_TYPE_SERVERLESS = 2;
}

message CreateClusterRequest {
  string team_pid = 1;
  string name = 2;
  ClusterType type = 3;
}

message CreateClusterResponse {
  string pid = 1;
  Cluster cluster = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteClusterRequest {
  string pid = 1;
}

message DeleteClusterResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message ListClustersRequest {
  string team_pid = 1;
}

message ListClustersResponse {
  string team_pid = 1;
  repeated Cluster clusters = 2;
}

message GetClusterRequest {
  string pid = 1;
}

message GetClusterResponse {
  string pid = 1;
  Cluster cluster = 2;
}

//===== DEVICES =====//

message Device {
  string pid = 1;
  string team_pid = 2;
  // A "common name" for the device that the user can use
  // to identify it.
  string name = 3;
  optional string description = 4;

  oneof model {
    GenericModel generic = 5;
  }
  // The IP addresses of the device. We use these to look
  // up the relevant device to enrich our flow with its information.
  repeated IpAddress addresses = 6;
  // User-defined labels for the device. Used to add more metadata
  // to query over.
  repeated std.v1.KeyValue labels = 7;

  google.protobuf.Timestamp created_at = 8;
  google.protobuf.Timestamp updated_at = 9;
}

message GenericModel {
  string model = 1;
  // It is possible that we have a known vendor (e.g Cisco or Arista)
  oneof vendor {
    string other_vendor = 2;
    Cisco cisco = 3;
    Arista arista = 4;
  }
}

message Cisco {}
message Arista {}

message IpAddress {
  bytes address = 1;
  IPVersion version = 2;
}

enum IPVersion {
  IPVERSION_UNSPECIFIED = 0;
  IPVERSION_IPV4 = 1;
  IPVERSION_IPV6 = 2;
}

message CreateDeviceRequest {
  string team_pid = 1;
  string name = 2;
  string description = 3;
  oneof model {
    GenericModel generic = 4;
  }
  repeated IpAddress addresses = 5;
  repeated std.v1.KeyValue labels = 6;
}

message CreateDeviceResponse {
  string pid = 1;
  Device device = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteDeviceRequest {
  string pid = 1;
}
message DeleteDeviceResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message UpdateDeviceRequest {
  string pid = 1;
  Device device = 2;
  google.protobuf.FieldMask update_mask = 3;
}

message UpdateDeviceResponse {
  string pid = 1;
  Device device = 2;
  google.protobuf.Timestamp updated_at = 3;
}

message GetDeviceRequest {
  string pid = 1;
}

message GetDeviceResponse {
  string pid = 1;
  Device device = 2;
}

message ListDevicesRequest {
  string team_pid = 1;
}

message ListDevicesResponse {
  string team_pid = 1;
  repeated Device devices = 2;
}

//===== QUERIES =====//
// TODO: MAKE SURE TO MAKE AN ASCII TEXT DIAGRAM EXPLAINING
// THE SHAPE OF THE DATA RETURNED BY THE QUERIES, ITS CONFUSING

message Query {
  string pid = 1;
  string team_pid = 2;
  string dataset_pid = 3;

  repeated Visualise visualise = 4;
  Where where = 5;
  repeated string group_by = 6;
  repeated Order order_by = 7;
  uint32 limit = 8;
  Clause having = 9;
  int64 start_time = 10;
  int64 end_time = 11;

  google.protobuf.Timestamp created_at = 12;
  google.protobuf.Timestamp updated_at = 13;
}

message Visualise {
  VisualiseOp op = 1;
  string field = 2;
}

enum VisualiseOp {
  VISUALISE_OP_UNSPECIFIED = 0;
  VISUALISE_OP_COUNT = 1;
  VISUALISE_OP_COUNT_DISTINCT = 2;
  VISUALISE_OP_SUM = 3;
  VISUALISE_OP_AVG = 4;
  VISUALISE_OP_MAX = 5;
  VISUALISE_OP_MIN = 6;
  // Unsupported
  VISUALISE_OP_P001 = 7;
  VISUALISE_OP_P01 = 8;
  VISUALISE_OP_P05 = 9;
  VISUALISE_OP_P10 = 10;
  VISUALISE_OP_P25 = 11;
  VISUALISE_OP_P50 = 12;
  VISUALISE_OP_P75 = 13;
  VISUALISE_OP_P90 = 14;
  VISUALISE_OP_P95 = 15;
  VISUALISE_OP_P99 = 16;
  VISUALISE_OP_P999 = 17;
  VISUALISE_OP_RATE_AVG = 18;
  VISUALISE_OP_RATE_SUM = 19;
  VISUALISE_OP_RATE_MAX = 20;
}

message Where {
  WhereOp op = 1;
  repeated Clause clauses = 2;
}

enum WhereOp {
  WHERE_OP_UNSPECIFIED = 0;
  WHERE_OP_AND = 1;
  WHERE_OP_OR = 2;
}

message Clause {
  string field = 1;
  string value = 2;
  CompareOp op = 3;
}

enum CompareOp {
  COMPARE_OP_UNSPECIFIED = 0;
  COMPARE_OP_EQUAL = 1;
  COMPARE_OP_NOT_EQUAL = 2;
  COMPARE_OP_GREATER_THAN = 3;
  COMPARE_OP_GREATER_THAN_OR_EQUAL = 4;
  COMPARE_OP_LESS_THAN = 5;
  COMPARE_OP_LESS_THAN_OR_EQUAL = 6;
  COMPARE_OP_CONTAINS = 7;
  COMPARE_OP_DOES_NOT_CONTAIN = 8;
  COMPARE_OP_IN = 9;
  COMPARE_OP_NOT_IN = 10;

  // ADD exists, does-not-exist, starts-with, does-not-start-with, ends-with, does-not-end-with
}

message Order {
  string field = 1;
  OrderOp order = 2;
}

enum OrderOp {
  ORDER_OP_UNSPECIFIED = 0;
  ORDER_OP_ASC = 1;
  ORDER_OP_DESC = 2;
}

message Series {
  repeated google.protobuf.Timestamp timestamps = 1;
  // The series of data returned by our query
  map<string, SeriesData> data = 2;
  // The name of the columns that are visualisations of the data (i.e the
  // operation on the data)
  repeated string visualisations = 3;
  // The names of the columns that are used to group the data
  repeated string groups = 4;
}

message SeriesData {
  // The name of the series. This is the field that was queried
  string name = 1;
  repeated std.v1.Value values = 2;
}

message Row {
  repeated string fields = 1;
  repeated RowValues row_values = 2;
}

message RowValues {
  repeated std.v1.Value values = 1;
}

message CreateQueryRequest {
  string team_pid = 1;
  string dataset_pid = 2;
  Query query = 3;
}

message CreateQueryResponse {
  string pid = 1;
  Query query = 2;
  google.protobuf.Timestamp created_at = 3;
}

// Request used to start a "query result" which kicks off a
// query execution job. Internally this creates a query result object
// in our database. The query result ID is returned in the response.
message SubmitQueryExecutionRequest {
  string query_pid = 1;
}

message SubmitQueryExecutionResponse {
  string query_pid = 1;
  string query_result_pid = 2;
}

message UpdateQueryExecutionRequest {
  QueryExecutionResult result = 1;
}

message UpdateQueryExecutionResponse {
  // Nexus ACK's the update
  bool ack = 1;
  string id = 2;
}

message PollQueryExecutionRequest {
  string dataset_pid = 1;
  string query_result_pid = 2;
}

message PollQueryExecutionResponse {
  QueryExecutionResult result = 1;
}

enum QueryExecutionStatus {
  QUERY_EXECUTION_STATUS_UNSPECIFIED = 0;
  QUERY_EXECUTION_STATUS_PENDING = 1;
  QUERY_EXECUTION_STATUS_RUNNING = 2;
  QUERY_EXECUTION_STATUS_COMPLETED = 3;
  QUERY_EXECUTION_STATUS_FAILED = 4;
}

// The request message sent to fluid instances to perform a request
message ExecQueryRequest {
  string dataset_pid = 1;
  string query_result_pid = 2;
  Query query = 3;
}

message QueryExecutionResult {
  string dataset_pid = 1;
  string query_result_pid = 2;
  QueryExecutionStatus status = 3;
  optional QueryExecutionData data = 4;
  optional string error_message = 5;
}

message QueryExecutionData {
  // The time series data. If many fields are queried at once
  // e.g select bytes, src_ip each field will have its own series
  Series series = 1;
  // This the "raw" data i.e the rows returned by the query.
  // Used to show the raw data in the UI
  repeated Row rows = 2;
}

//===== AGENT LIFECYCLE =====//
message HeartbeatRequest {
  // The agent ID. These are generated by the agent themselves.
  // They are of the form agt_{nanoid}
  string id = 1;
  string cluster_pid = 2;
}

message HeartbeatResponse {
  string id = 1;
  string cluster_pid = 2;
}

enum AgentStatus {
  AGENT_STATUS_UNSPECIFIED = 0;
  // The last heartbeat was received within the last 5 minutes.
  AGENT_STATUS_ALIVE = 1;
  // The last heartbeat was received more than 5 minutes ago.
  AGENT_STATUS_STALE = 2;
  // The last heartbeat was received more than 30 minutes ago.
  AGENT_STATUS_UNRESPONSIVE = 3;
  // The agent has not been heard of in the last 8 hours.
  AGENT_STATUS_DEAD = 4;
}

message AgentMetadata {
  string id = 1;
  string cluster_pid = 2;
  string version = 3;
  // The status of the agent. The control plane manages this field.
  // It is determined by the heartbeat recency.
  AgentStatus status = 4;
  // The last heartbeat we received.
  google.protobuf.Timestamp last_heartbeat = 5;
}

message Heartbeat {
  string agent_id = 1;
  google.protobuf.Timestamp timestamp = 2;
}

//===== CONTROL MESSAGES =====//
//
// Control messages sent by the server --> agents. For each of them,
// since we don't expect them to be changed often, we just send the
// entire configuration on each change (for the given message)

message ControlMessageRequest {
  string request_id = 1;
  ControlMessage control = 2;
}

message ControlMessageResponse {
  string request_id = 1;
  ControlMessage control = 2;
  bool success = 3;
  string error = 4;
}

message ControlMessage {
  oneof message {
    TelemetryControl telemetry = 1;
    DeviceControl devices = 2;
  }
}

// Telemetry control messages
message TelemetryControl {
  // Whether or not to export telemetry data. This can be
  // switched off to prevent data from being written to
  // the catalogue and to blob storage.
  bool export = 1;
}

// Device control messages
message DeviceControl {
  repeated Device devices = 1;
}
