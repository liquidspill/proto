syntax = "proto3";

package nexus.controlplane.v1;

import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "std/v1/std.proto";

option go_package = "github.com/liquidspill/proto/go/nexus/controlplane/v1;controlplanev1";

// The control plane service manages all operational aspects of the system. This includes
// owning the management of clusters, devices, queries, etc. Additionally, it manages the
// lifecycle of our agents.
service ControlPlaneService {
  //===== DATASET MANAGEMENT =====//

  rpc CreateDataset(CreateDatasetRequest) returns (CreateDatasetResponse) {}
  rpc DeleteDataset(DeleteDatasetRequest) returns (DeleteDatasetResponse) {}
  rpc ListDatasets(ListDatasetsRequest) returns (ListDatasetsResponse) {}
  rpc GetDataset(GetDatasetRequest) returns (GetDatasetResponse) {}

  //===== CLUSTER MANAGEMENT =====//

  rpc CreateCluster(CreateClusterRequest) returns (CreateClusterResponse) {}
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {}
  rpc GetCluster(GetClusterRequest) returns (GetClusterResponse) {}

  //===== DEVICE MANAGEMENT =====//

  rpc CreateDevice(CreateDeviceRequest) returns (CreateDeviceResponse) {}
  rpc DeleteDevice(DeleteDeviceRequest) returns (DeleteDeviceResponse) {}
  rpc UpdateDevice(UpdateDeviceRequest) returns (UpdateDeviceResponse) {}
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse) {}
  rpc GetDevice(GetDeviceRequest) returns (GetDeviceResponse) {}

  //===== QUERY MANAGEMENT =====//

  rpc CreateQuery(CreateQueryRequest) returns (CreateQueryResponse) {}
  // Starts the execution of a given query (nexus -> fluid)
  rpc SubmitQueryExecution(SubmitQueryExecutionRequest) returns (SubmitQueryExecutionResponse) {}
  // Registers updates of a query (fluid -> nexus)
  rpc UpdateQueryExecution(UpdateQueryExecutionRequest) returns (UpdateQueryExecutionResponse) {}
  // Poll the query execution job. Used by the client to get the status of
  // a query. If it is complete, the result will be returned alongside it.
  rpc PollQueryExecution(PollQueryExecutionRequest) returns (PollQueryExecutionResponse) {}

  //===== LIFECYCLE MANAGEMENT =====//

  // Handles heartbeats from Fluid collectors and query workers
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}

  // Add a stop agent request which can hit a service running in the
  // agent that will cause it to quit
  // Add a update config request
}

//===== DATASETS =====//

message Dataset {
  string pid = 1;
  string team_pid = 2;
  string name = 3;
  optional string description = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

message CreateDatasetRequest {
  string team_pid = 1;
  string name = 2;
  optional string description = 3;
}

message CreateDatasetResponse {
  string pid = 1;
  Dataset dataset = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteDatasetRequest {
  string pid = 1;
}

message DeleteDatasetResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message ListDatasetsRequest {
  string team_pid = 1;
}

message ListDatasetsResponse {
  string team_pid = 1;
  repeated Dataset datasets = 2;
}

message GetDatasetRequest {
  string pid = 1;
}

message GetDatasetResponse {
  string pid = 1;
  Dataset dataset = 2;
}

//===== CLUSTERS =====//

// Cluster represents the query/read side of the system
// where a distributed query engine runs to query manifests
// and calculate final results. Clusters can be either
// BYOC (bring your own cloud) or serverless (managed in our cloud).
message Cluster {
  string pid = 1;
  string team_pid = 2;
  string name = 3;
  ClusterType type = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

enum ClusterType {
  CLUSTER_TYPE_UNSPECIFIED = 0;
  // The cluster runs in their own cloud
  CLUSTER_TYPE_BYOC = 1;
  // We run the cluster in our cloud, on behalf of the user
  CLUSTER_TYPE_SERVERLESS = 2;
}

message CreateClusterRequest {
  string team_pid = 1;
  string name = 2;
  ClusterType type = 3;
}

message CreateClusterResponse {
  string pid = 1;
  Cluster cluster = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteClusterRequest {
  string pid = 1;
}

message DeleteClusterResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message ListClustersRequest {
  string team_pid = 1;
}

message ListClustersResponse {
  string team_pid = 1;
  repeated Cluster clusters = 2;
}

message GetClusterRequest {
  string pid = 1;
}

message GetClusterResponse {
  string pid = 1;
  Cluster cluster = 2;
}

//===== DEVICES =====//

message Device {
  string pid = 1;
  string team_pid = 2;
  // A "common name" for the device that the user can use
  // to identify it.
  string name = 3;
  optional string description = 4;

  oneof model {
    GenericModel generic = 5;
  }
  // The IP addresses of the device. We use these to look
  // up the relevant device to enrich our flow with its information.
  repeated IpAddress addresses = 6;
  // User-defined labels for the device. Used to add more metadata
  // to query over.
  repeated std.v1.KeyValue labels = 7;

  google.protobuf.Timestamp created_at = 8;
  google.protobuf.Timestamp updated_at = 9;
}

message GenericModel {
  string model = 1;
  // It is possible that we have a known vendor (e.g Cisco or Arista)
  oneof vendor {
    string other_vendor = 2;
    Cisco cisco = 3;
    Arista arista = 4;
  }
}

message Cisco {}
message Arista {}

message IpAddress {
  bytes address = 1;
  IPVersion version = 2;
}

enum IPVersion {
  IPVERSION_UNSPECIFIED = 0;
  IPVERSION_IPV4 = 1;
  IPVERSION_IPV6 = 2;
}

message CreateDeviceRequest {
  string team_pid = 1;
  string name = 2;
  string description = 3;
  oneof model {
    GenericModel generic = 4;
  }
  repeated IpAddress addresses = 5;
  repeated std.v1.KeyValue labels = 6;
}

message CreateDeviceResponse {
  string pid = 1;
  Device device = 2;
  google.protobuf.Timestamp created_at = 3;
}

message DeleteDeviceRequest {
  string pid = 1;
}
message DeleteDeviceResponse {
  string pid = 1;
  google.protobuf.Timestamp deleted_at = 2;
}

message UpdateDeviceRequest {
  string pid = 1;
  Device device = 2;
  google.protobuf.FieldMask update_mask = 3;
}

message UpdateDeviceResponse {
  string pid = 1;
  Device device = 2;
  google.protobuf.Timestamp updated_at = 3;
}

message GetDeviceRequest {
  string pid = 1;
}

message GetDeviceResponse {
  string pid = 1;
  Device device = 2;
}

message ListDevicesRequest {
  string team_pid = 1;
}

message ListDevicesResponse {
  string team_pid = 1;
  repeated Device devices = 2;
}

//===== QUERIES =====//
// TODO: MAKE SURE TO MAKE AN ASCII TEXT DIAGRAM EXPLAINING
// THE SHAPE OF THE DATA RETURNED BY THE QUERIES, ITS CONFUSING

message Query {
  string pid = 1;
  string team_pid = 2;
  string dataset_pid = 3;

  repeated Visualise visualise = 4;
  Where where = 5;
  repeated string group_by = 6;
  repeated Order order_by = 7;
  uint32 limit = 8;
  Clause having = 9;
  int64 start_time = 10;
  int64 end_time = 11;
  int32 granularity = 12;

  google.protobuf.Timestamp created_at = 13;
  google.protobuf.Timestamp updated_at = 14;
}

message Visualise {
  VisualiseOp op = 1;
  string field = 2;
}

enum VisualiseOp {
  VISUALISE_OP_UNSPECIFIED = 0;
  VISUALISE_OP_COUNT = 1;
  VISUALISE_OP_COUNT_DISTINCT = 2;
  VISUALISE_OP_SUM = 3;
  VISUALISE_OP_AVG = 4;
  VISUALISE_OP_MAX = 5;
  VISUALISE_OP_MIN = 6;
  // Unsupported
  VISUALISE_OP_P001 = 7;
  VISUALISE_OP_P01 = 8;
  VISUALISE_OP_P05 = 9;
  VISUALISE_OP_P10 = 10;
  VISUALISE_OP_P25 = 11;
  VISUALISE_OP_P50 = 12;
  VISUALISE_OP_P75 = 13;
  VISUALISE_OP_P90 = 14;
  VISUALISE_OP_P95 = 15;
  VISUALISE_OP_P99 = 16;
  VISUALISE_OP_P999 = 17;
  VISUALISE_OP_RATE_AVG = 18;
  VISUALISE_OP_RATE_SUM = 19;
  VISUALISE_OP_RATE_MAX = 20;
}

message Where {
  WhereOp op = 1;
  repeated Clause clauses = 2;
}

enum WhereOp {
  WHERE_OP_UNSPECIFIED = 0;
  WHERE_OP_AND = 1;
  WHERE_OP_OR = 2;
}

message Clause {
  string field = 1;
  string value = 2;
  CompareOp op = 3;
}

enum CompareOp {
  COMPARE_OP_UNSPECIFIED = 0;
  COMPARE_OP_EQUAL = 1;
  COMPARE_OP_NOT_EQUAL = 2;
  COMPARE_OP_GREATER_THAN = 3;
  COMPARE_OP_GREATER_THAN_OR_EQUAL = 4;
  COMPARE_OP_LESS_THAN = 5;
  COMPARE_OP_LESS_THAN_OR_EQUAL = 6;
  COMPARE_OP_CONTAINS = 7;
  COMPARE_OP_DOES_NOT_CONTAIN = 8;
  COMPARE_OP_IN = 9;
  COMPARE_OP_NOT_IN = 10;

  // ADD exists, does-not-exist, starts-with, does-not-start-with, ends-with, does-not-end-with
}

message Order {
  string field = 1;
  OrderOp order = 2;
}

enum OrderOp {
  ORDER_OP_UNSPECIFIED = 0;
  ORDER_OP_ASC = 1;
  ORDER_OP_DESC = 2;
}

message CreateQueryRequest {
  string team_pid = 1;
  string dataset_pid = 2;
  Query query = 3;
}

message CreateQueryResponse {
  string pid = 1;
  Query query = 2;
  google.protobuf.Timestamp created_at = 3;
}

// Request used to start a "query result" which kicks off a
// query execution job. Internally this creates a query result object
// in our database. The query result ID is returned in the response.
message SubmitQueryExecutionRequest {
  string query_pid = 1;
}

message SubmitQueryExecutionResponse {
  string query_pid = 1;
  string query_result_pid = 2;
}

message UpdateQueryExecutionRequest {
  QueryExecutionResult result = 1;
}

message UpdateQueryExecutionResponse {
  // Nexus ACK's the update
  bool ack = 1;
  string id = 2;
}

message PollQueryExecutionRequest {
  string dataset_pid = 1;
  string query_result_pid = 2;
}

message PollQueryExecutionResponse {
  QueryExecutionResult result = 1;
}

enum QueryExecutionStatus {
  QUERY_EXECUTION_STATUS_UNSPECIFIED = 0;
  QUERY_EXECUTION_STATUS_PENDING = 1;
  QUERY_EXECUTION_STATUS_RUNNING = 2;
  QUERY_EXECUTION_STATUS_COMPLETED = 3;
  QUERY_EXECUTION_STATUS_FAILED = 4;
}

// The request message sent to fluid instances to perform a request
message ExecQueryRequest {
  string dataset_pid = 1;
  string query_result_pid = 2;
  Query query = 3;
}

message QueryExecutionResult {
  string dataset_pid = 1;
  string query_result_pid = 2;
  QueryExecutionStatus status = 3;
  optional QueryResult results = 4;
  optional string error_message = 5;
}

// QueryResult holds the complete graph data from a single query.
// Timestamps are shared across all visualisations since they come from one query.
//
// Example: Query "SELECT src_ip, SUM(bytes), COUNT(*) FROM flows GROUP BY src_ip, timestamp"
//
//   timestamps: [2024-01-01T00:00:00Z, 2024-01-01T00:01:00Z, 2024-01-01T00:02:00Z]
//   groups: ["src_ip"]
//
//   series: [
//     {
//       visualisation: "sum_bytes",
//       lines: [
//         { group_values: ["192.168.1.10"], values: [1048576, 2097152, 524288] },
//         { group_values: ["10.0.0.5"],     values: [524288, 524288, 1048576] },
//       ]
//     },
//     {
//       visualisation: "count",
//       lines: [
//         { group_values: ["192.168.1.10"], values: [150, 300, 75] },
//         { group_values: ["10.0.0.5"],     values: [100, 100, 200] },
//       ]
//     },
//   ]
//
// Renders as two graphs:
//   Graph 1 (sum_bytes): 2 lines, one per src_ip
//   Graph 2 (count): 2 lines, one per src_ip
//
message QueryResult {
  // Shared x-axis timestamps for all series.
  // This field is populated by the Nexus control plane before
  // passing it onto the client
  repeated google.protobuf.Timestamp timestamps = 1;

  // GROUP BY column names, shared across all series.
  repeated string groups = 2;

  // One series per visualisation/aggregation.
  // This field is populated by the Nexus control plane before
  // passing it onto the client
  repeated Series series = 3;

  // Tabular view of the same data (for the overview table).
  // This field is populated by the fluid query engine after
  // a query is successfully executed.
  Table table = 4;
}

message QueryResultSchema {
  repeated string visualisations = 1;
  repeated string groups = 2;
  repeated string aggregates = 3;
  repeated QueryResultSchemaField fields = 4;
}

message QueryResultSchemaField {
  QueryResultColumnType type = 1;
  string name = 2;
  int32 column_index = 3;
}

enum QueryResultColumnType {
  QUERY_RESULT_COLUMN_TYPE_UNSPECIFIED = 0;
  QUERY_RESULT_COLUMN_TYPE_VISUALISATION = 1;
  QUERY_RESULT_COLUMN_TYPE_GROUP = 2;
  QUERY_RESULT_COLUMN_TYPE_AGGREGATE = 3;
  QUERY_RESULT_COLUMN_TYPE_TIMESTAMP = 4;
}

// Series represents a single graph for one aggregation metric.
message Series {
  // The aggregation being visualised (y-axis label / graph title).
  string visualisation = 1;

  // Each line on the graph.
  repeated Line lines = 2;
}

// Line represents a single data series on the graph.
message Line {
  // Values for each group column, aligned with QueryResult.groups.
  repeated string group_values = 1;

  // Y-axis values, aligned with QueryResult.timestamps.
  repeated std.v1.Value values = 2;
}

// Table represents tabular row data for display in a data grid.
//
// Example: Query "SELECT src_ip, region, SUM(bytes), COUNT(*) FROM flows GROUP BY src_ip, region"
//
//   columns: ["src_ip", "region", "sum_bytes", "count"]
//   rows: [
//     { values: ["192.168.1.10", "us-east", 1048576, 150] },
//     { values: ["10.0.0.5", "eu-west", 524288, 75] },
//   ]
//
message Table {
  // The aggregation columns, what we end up visualising e.g COUNT(*)
  repeated TableColumn visualisations = 1;
  // The columns that are used for grouping e.g src_ip, region
  repeated TableColumn groups = 2;
  // Each row of data.
  repeated TableRow rows = 3;
}

message TableColumn {
  string name = 1;
  int32 index = 2;
}

// TableRow holds values for a single row, aligned with Table.columns.
message TableRow {
  repeated std.v1.Value values = 1;
}

//===== LIFECYCLE MANAGEMENT =====//

message HeartbeatRequest {
  // The ID of the component performing the heartbeat. These are generally
  // generated by the component themselves.
  // They are of the form {type}_{nanoid}
  string id = 1;
  string team_pid = 2;

  oneof metadata {
    CollectorMetadata collector = 3;
    TapMetadata tap = 4;
  }
}

message HeartbeatResponse {
  string id = 1;
}

enum ComponentType {
  COMPONENT_TYPE_UNSPECIFIED = 0;
  COMPONENT_TYPE_COLLECTOR = 1;
  COMPONENT_TYPE_TAP = 2;
}

enum ComponentHealthStatus {
  COMPONENT_HEALTH_STATUS_UNSPECIFIED = 0;
  // The last heartbeat was received within the last 5 minutes.
  COMPONENT_HEALTH_STATUS_ALIVE = 1;
  // The last heartbeat was received more than 5 minutes ago.
  COMPONENT_HEALTH_STATUS_STALE = 2;
  // The last heartbeat was received more than 30 minutes ago.
  COMPONENT_HEALTH_STATUS_UNRESPONSIVE = 3;
  // The collector has not been heard of in the last 8 hours.
  COMPONENT_HEALTH_STATUS_DEAD = 4;
}

message CollectorMetadata {
  string id = 1;
  string version = 2;
  // The status of the Fluid Collector. The control plane manages this field.
  // It is determined by the heartbeat recency.
  ComponentHealthStatus status = 3;
  // The last heartbeat we received.
  google.protobuf.Timestamp last_heartbeat = 4;

  CollectorMetrics metrics = 5;
}

message CollectorMetrics {
  float cpu_usage_percent = 1;
  float memory_usage_percent = 2;
  float disk_usage_percent = 3;

  uint64 memory_used_bytes = 4;
  uint64 memory_available_bytes = 5;

  uint64 disk_used_bytes = 6;
  uint64 disk_available_bytes = 7;

  uint64 s3_put_requests_total = 8;
  uint64 s3_errors_total = 9;
  double avg_s3_put_latency_ms = 10;
  double p99_s3_put_latency_ms = 11;
  uint64 s3_bytes_uploaded = 12;

  float ring_buffer_percent = 13;

  // The number of flows we've received in totality. This should
  // be: flows_written_total + flows_dropped_total
  uint64 flows_received_total = 14;
  // Total number of flows written to S3
  uint64 flows_written_total = 15;
  // Total number of flows we've dropped (due to a full ring buffer)
  uint64 flows_dropped_total = 16;

  google.protobuf.Timestamp collected_at = 17;
}

message TapMetadata {
  string id = 1;
  string version = 2;
  ComponentHealthStatus status = 3;
  google.protobuf.Timestamp last_heartbeat = 5;
}

//===== CONTROL MESSAGES =====//
// Control messages sent by the server --> agents. For each of them,
// since we don't expect them to be changed often, we just send the
// entire configuration on each change (for the given message)

message ControlMessageRequest {
  string request_id = 1;
  ControlMessage control = 2;
}

message ControlMessageResponse {
  string request_id = 1;
  ControlMessage control = 2;
  bool success = 3;
  string error = 4;
}

message ControlMessage {
  oneof message {
    TelemetryControl telemetry = 1;
    DeviceControl devices = 2;
  }
}

// Telemetry control messages
message TelemetryControl {
  // Whether or not to export telemetry data. This can be
  // switched off to prevent data from being written to
  // the catalogue and to blob storage.
  bool export = 1;
}

// Device control messages
message DeviceControl {
  repeated Device devices = 1;
}
