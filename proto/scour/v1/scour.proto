syntax = "proto3";

package scour.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/liquidspill/proto/go/scour/v1;scourv1";

// ===== Query definitions =====

message CreateQueryRequest {
  Query query = 1;
}

message CreateQueryResponse {
  string id = 1;
  // The time series data. If many fields are queried at once e.g select bytes, src_ip
  // each field will have its own series
  Series series = 2;
  // This the "raw" data i.e the rows returned by the query. Used to show the raw data
  // in the UI
  Result result = 3;
}

message Query {
  Visualise visualise = 1;
  Where where = 2;
  repeated string group_by = 3;
  repeated OrderBy order_by = 4;
  uint32 limit = 5;
  Clause having = 6;
  int64 start_time = 7;
  int64 end_time = 8;
}

message Visualise {
  VisOp op = 1;
  string field = 2;
}

enum VisOp {
  VIS_OP_UNSPECIFIED = 0;
  VIS_OP_COUNT = 1;
  VIS_OP_COUNT_DISTINCT = 2;
  VIS_OP_SUM = 3;
  VIS_OP_AVG = 4;
  VIS_OP_MAX = 5;
  VIS_OP_MIN = 6;
  // Unsupported
  VIS_OP_P001 = 7;
  VIS_OP_P01 = 8;
  VIS_OP_P05 = 9;
  VIS_OP_P10 = 10;
  VIS_OP_P25 = 11;
  VIS_OP_P50 = 12;
  VIS_OP_P75 = 13;
  VIS_OP_P90 = 14;
  VIS_OP_P95 = 15;
  VIS_OP_P99 = 16;
  VIS_OP_P999 = 17;
  VIS_OP_RATE_AVG = 18;
  VIS_OP_RATE_SUM = 19;
  VIS_OP_RATE_MAX = 20;
}

message Where {
  WhereOp op = 1;
  repeated Clause clauses = 2;
}

enum WhereOp {
  WHERE_OP_UNSPECIFIED = 0;
  WHERE_OP_AND = 1;
  WHERE_OP_OR = 2;
}

message Clause {
  string field = 1;
  string value = 2;
  CompareOp op = 3;
}

enum CompareOp {
  COMPARE_OP_UNSPECIFIED = 0;
  COMPARE_OP_EQUAL = 1;
  COMPARE_OP_NOT_EQUAL = 2;
  COMPARE_OP_GREATER_THAN = 3;
  COMPARE_OP_GREATER_THAN_OR_EQUAL = 4;
  COMPARE_OP_LESS_THAN = 5;
  COMPARE_OP_LESS_THAN_OR_EQUAL = 6;
  COMPARE_OP_CONTAINS = 7;
  COMPARE_OP_DOES_NOT_CONTAIN = 8;
  COMPARE_OP_IN = 9;
  COMPARE_OP_NOT_IN = 10;
}

message OrderBy {
  string field = 1;
  OrderOp order = 2;
}

enum OrderOp {
  ORDER_OP_UNSPECIFIED = 0;
  ORDER_OP_ASC = 1;
  ORDER_OP_DESC = 2;
}

message Series {
  repeated google.protobuf.Timestamp timestamps = 1;
  repeated SeriesData data = 2;
}

message SeriesData {
  // The name of the series. This is the field that was queried
  string name = 1;
  repeated int64 values = 2;
}

message Result {
  repeated string fields = 1;
  repeated Row rows = 2;
}

message Row {
  repeated Value values = 1;
}

message Value {
  oneof kind {
    int32 int32_value = 1;
    int64 int64_value = 2;
    uint32 uint32_value = 3;
    uint64 uint64_value = 4;
    bool bool_value = 5;
    string string_value = 6;
    bytes bytes_value = 7;
    google.protobuf.Timestamp timestamp_value = 8;
  }
}

// ===== Parquet defintions =====

// These are used to convert data from Rust structs into Protobufs so we can store
// them in our cache. The below set of structs is generated from the ParquetMetadata
// in parquet-rs (https://docs.rs/parquet)

message ParquetMetadata {
  FileMetadata file_metadata = 1;
  repeated Thrift row_groups = 2;
}

message Thrift {
  bytes bytes = 1;
}

message FileMetadata {
  int32 version = 1;
  int64 num_rows = 2;
  optional string created_by = 3;
  repeated KeyValue key_value_metadata = 4;
  repeated Thrift schema_descriptor = 5;
  repeated ColumnOrder column_orders = 6;
}

message KeyValue {
  string key = 1;
  optional string value = 2;
}

message ColumnOrder {
  OrderType type = 1;
  SortOrder sort_order = 2;
}

enum OrderType {
  ORDER_TYPE_UNSPECIFIED = 0;
  ORDER_TYPE_UNDEFINED = 1;
  ORDER_TYPE_TYPE_DEFINED_ORDER = 2;
}

enum SortOrder {
  SORT_ORDER_UNSPECIFIED = 0;
  SORT_ORDER_UNDEFINED = 1;
  SORT_ORDER_SIGNED = 2;
  SORT_ORDER_UNSIGNED = 3;
}
