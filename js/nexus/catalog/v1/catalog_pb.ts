// @generated by protoc-gen-es v2.10.0 with parameter "target=ts"
// @generated from file nexus/catalog/v1/catalog.proto (package nexus.catalog.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file nexus/catalog/v1/catalog.proto.
 */
export const file_nexus_catalog_v1_catalog: GenFile = /*@__PURE__*/
  fileDesc("Ch5uZXh1cy9jYXRhbG9nL3YxL2NhdGFsb2cucHJvdG8SEG5leHVzLmNhdGFsb2cudjEiWgoVQ3JlYXRlTWFuaWZlc3RSZXF1ZXN0EhMKC2NsdXN0ZXJfcGlkGAEgASgJEiwKCG1hbmlmZXN0GAIgASgLMhoubmV4dXMuY2F0YWxvZy52MS5NYW5pZmVzdCKYAQoWQ3JlYXRlTWFuaWZlc3RSZXNwb25zZRILCgNwaWQYASABKAkSEwoLY2x1c3Rlcl9waWQYAiABKAkSLAoIbWFuaWZlc3QYAyABKAsyGi5uZXh1cy5jYXRhbG9nLnYxLk1hbmlmZXN0Ei4KCmNyZWF0ZWRfYXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIokBChRMaXN0TWFuaWZlc3RzUmVxdWVzdBITCgtjbHVzdGVyX3BpZBgBIAEoCRIuCgpzdGFydF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiuQEKFUxpc3RNYW5pZmVzdHNSZXNwb25zZRITCgtjbHVzdGVyX3BpZBgBIAEoCRIuCgpzdGFydF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLQoJbWFuaWZlc3RzGAQgAygLMhoubmV4dXMuY2F0YWxvZy52MS5NYW5pZmVzdCLVAgoITWFuaWZlc3QSCwoDcGlkGAEgASgJEjEKC2NsdXN0ZXJfa2V5GAIgASgLMhwubmV4dXMuY2F0YWxvZy52MS5DbHVzdGVyS2V5EjQKCWxvY2F0aW9ucxgDIAMoCzIhLm5leHVzLmNhdGFsb2cudjEuU3RvcmFnZUxvY2F0aW9uEgwKBHNpemUYBCABKAQSEQoJcm93X2NvdW50GAUgASgEEi4KCmNyZWF0ZWRfYXQYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjgKB2NvbHVtbnMYByADKAsyJy5uZXh1cy5jYXRhbG9nLnYxLk1hbmlmZXN0LkNvbHVtbnNFbnRyeRpICgxDb2x1bW5zRW50cnkSCwoDa2V5GAEgASgJEicKBXZhbHVlGAIgASgLMhgubmV4dXMuY2F0YWxvZy52MS5Db2x1bW46AjgBInQKBkNvbHVtbhIMCgRuYW1lGAEgASgJEjAKCnN0YXRpc3RpY3MYAiABKAsyHC5uZXh1cy5jYXRhbG9nLnYxLlN0YXRpc3RpY3MSKgoEdHlwZRgDIAEoDjIcLm5leHVzLmNhdGFsb2cudjEuQ29sdW1uVHlwZSLIAQoPU3RvcmFnZUxvY2F0aW9uEj4KDXMzX2NvbXBhdGlibGUYASABKAsyJS5uZXh1cy5jYXRhbG9nLnYxLlMzQ29tcGF0aWJsZVN0b3JhZ2VIABI4CgphenVyZV9ibG9iGAIgASgLMiIubmV4dXMuY2F0YWxvZy52MS5BenVyZUJsb2JTdG9yYWdlSAASLwoFbG9jYWwYAyABKAsyHi5uZXh1cy5jYXRhbG9nLnYxLkxvY2FsU3RvcmFnZUgAQgoKCGxvY2F0aW9uIlQKE1MzQ29tcGF0aWJsZVN0b3JhZ2USEAoIZW5kcG9pbnQYASABKAkSDgoGYnVja2V0GAIgASgJEgsKA2tleRgDIAEoCRIOCgZyZWdpb24YBCABKAkiZwoQQXp1cmVCbG9iU3RvcmFnZRIUCgxhY2NvdW50X25hbWUYASABKAkSEQoJY29udGFpbmVyGAIgASgJEhEKCWJsb2JfbmFtZRgDIAEoCRIXCg9lbmRwb2ludF9zdWZmaXgYBCABKAkiHAoMTG9jYWxTdG9yYWdlEgwKBHBhdGgYASABKAkivgMKClN0YXRpc3RpY3MSEwoJbWluX2ludDMyGAEgASgFSAASEwoJbWluX2ludDY0GAIgASgDSAASFAoKbWluX3VpbnQzMhgDIAEoDUgAEhQKCm1pbl91aW50NjQYBCABKARIABISCghtaW5fYm9vbBgFIAEoCEgAEhQKCm1pbl9zdHJpbmcYBiABKAlIABITCgltaW5fYnl0ZXMYByABKAxIABIzCg1taW5fdGltZXN0YW1wGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEhMKCW1heF9pbnQzMhgJIAEoBUgBEhMKCW1heF9pbnQ2NBgKIAEoA0gBEhQKCm1heF91aW50MzIYCyABKA1IARIUCgptYXhfdWludDY0GAwgASgESAESEgoIbWF4X2Jvb2wYDSABKAhIARIUCgptYXhfc3RyaW5nGA4gASgJSAESEwoJbWF4X2J5dGVzGA8gASgMSAESMwoNbWF4X3RpbWVzdGFtcBgQIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIARIOCgZmaWx0ZXIYESABKAxCBQoDbWluQgUKA21heCI7CgpDbHVzdGVyS2V5Ei0KCXRpbWVzdGFtcBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAipgEKCkNvbXBhY3Rpb24SLgoKY3JlYXRlZF9hdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMAoFbGV2ZWwYAiABKA4yIS5uZXh1cy5jYXRhbG9nLnYxLkNvbXBhY3Rpb25MZXZlbBIoCgZ3aW5kb3cYAyABKAsyGC5uZXh1cy5jYXRhbG9nLnYxLldpbmRvdxIMCgRzaXplGAQgASgEInQKBldpbmRvdxIMCgRzaXplGAEgASgNEi4KCnN0YXJ0X3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiwKCGVuZF90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCKhAQoFVmFsdWUSLgoKY3JlYXRlZF9hdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASKwoEY29tcBgDIAEoDjIdLm5leHVzLmNhdGFsb2cudjEuQ29tcHJlc3Npb24SCwoDcmF3GAQgASgMIv4BCgdWYXJpYW50EhcKDWludDMyX3ZhcmlhbnQYASABKAVIABIXCg1pbnQ2NF92YXJpYW50GAIgASgDSAASGAoOdWludDMyX3ZhcmlhbnQYAyABKA1IABIYCg51aW50NjRfdmFyaWFudBgEIAEoBEgAEhYKDGJvb2xfdmFyaWFudBgFIAEoCEgAEhgKDnN0cmluZ192YXJpYW50GAYgASgJSAASFwoNYnl0ZXNfdmFyaWFudBgHIAEoDEgAEjcKEXRpbWVzdGFtcF92YXJpYW50GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAQgkKB3ZhcmlhbnQqxgIKCkNvbHVtblR5cGUSGwoXQ09MVU1OX1RZUEVfVU5TUEVDSUZJRUQQABIUChBDT0xVTU5fVFlQRV9JTlQ4EAESFQoRQ09MVU1OX1RZUEVfSU5UMTYQAhIVChFDT0xVTU5fVFlQRV9JTlQzMhADEhUKEUNPTFVNTl9UWVBFX0lOVDY0EAQSFQoRQ09MVU1OX1RZUEVfVUlOVDgQBRIWChJDT0xVTU5fVFlQRV9VSU5UMTYQBhIWChJDT0xVTU5fVFlQRV9VSU5UMzIQBxIWChJDT0xVTU5fVFlQRV9VSU5UNjQQCBIWChJDT0xVTU5fVFlQRV9TVFJJTkcQCRIXChNDT0xVTU5fVFlQRV9CT09MRUFOEAoSGQoVQ09MVU1OX1RZUEVfVElNRVNUQU1QEAsSFQoRQ09MVU1OX1RZUEVfQllURVMQDCpoCg9Db21wYWN0aW9uTGV2ZWwSIAocQ09NUEFDVElPTl9MRVZFTF9VTlNQRUNJRklFRBAAEhkKFUNPTVBBQ1RJT05fTEVWRUxfWkVSTxABEhgKFENPTVBBQ1RJT05fTEVWRUxfT05FEAIqbQoLQ29tcHJlc3Npb24SGwoXQ09NUFJFU1NJT05fVU5TUEVDSUZJRUQQABIUChBDT01QUkVTU0lPTl9aU1REEAESEwoPQ09NUFJFU1NJT05fTFo0EAISFgoSQ09NUFJFU1NJT05fU05BUFBZEAMy2wEKDkNhdGFsb2dTZXJ2aWNlEmUKDkNyZWF0ZU1hbmlmZXN0EicubmV4dXMuY2F0YWxvZy52MS5DcmVhdGVNYW5pZmVzdFJlcXVlc3QaKC5uZXh1cy5jYXRhbG9nLnYxLkNyZWF0ZU1hbmlmZXN0UmVzcG9uc2UiABJiCg1MaXN0TWFuaWZlc3RzEiYubmV4dXMuY2F0YWxvZy52MS5MaXN0TWFuaWZlc3RzUmVxdWVzdBonLm5leHVzLmNhdGFsb2cudjEuTGlzdE1hbmlmZXN0c1Jlc3BvbnNlIgBCPFo6Z2l0aHViLmNvbS9saXF1aWRzcGlsbC9wcm90by9nby9uZXh1cy9jYXRhbG9nL3YxO2NhdGFsb2d2MWIGcHJvdG8z", [file_google_protobuf_timestamp]);

/**
 * @generated from message nexus.catalog.v1.CreateManifestRequest
 */
export type CreateManifestRequest = Message<"nexus.catalog.v1.CreateManifestRequest"> & {
  /**
   * @generated from field: string cluster_pid = 1;
   */
  clusterPid: string;

  /**
   * @generated from field: nexus.catalog.v1.Manifest manifest = 2;
   */
  manifest?: Manifest;
};

/**
 * Describes the message nexus.catalog.v1.CreateManifestRequest.
 * Use `create(CreateManifestRequestSchema)` to create a new message.
 */
export const CreateManifestRequestSchema: GenMessage<CreateManifestRequest> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 0);

/**
 * @generated from message nexus.catalog.v1.CreateManifestResponse
 */
export type CreateManifestResponse = Message<"nexus.catalog.v1.CreateManifestResponse"> & {
  /**
   * @generated from field: string pid = 1;
   */
  pid: string;

  /**
   * @generated from field: string cluster_pid = 2;
   */
  clusterPid: string;

  /**
   * @generated from field: nexus.catalog.v1.Manifest manifest = 3;
   */
  manifest?: Manifest;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;
};

/**
 * Describes the message nexus.catalog.v1.CreateManifestResponse.
 * Use `create(CreateManifestResponseSchema)` to create a new message.
 */
export const CreateManifestResponseSchema: GenMessage<CreateManifestResponse> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 1);

/**
 * ListManifestsRequest queries for Manifests within a time range.
 * Used by query engines to discover which data files contain relevant data.
 *
 * @generated from message nexus.catalog.v1.ListManifestsRequest
 */
export type ListManifestsRequest = Message<"nexus.catalog.v1.ListManifestsRequest"> & {
  /**
   * @generated from field: string cluster_pid = 1;
   */
  clusterPid: string;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 3;
   */
  endTime?: Timestamp;
};

/**
 * Describes the message nexus.catalog.v1.ListManifestsRequest.
 * Use `create(ListManifestsRequestSchema)` to create a new message.
 */
export const ListManifestsRequestSchema: GenMessage<ListManifestsRequest> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 2);

/**
 * ListManifestsResponse returns all Manifests matching the query criteria.
 * The returned Manifest descriptors include column statistics that enable
 * query engines to perform predicate pushdown and skip irrelevant files.
 *
 * @generated from message nexus.catalog.v1.ListManifestsResponse
 */
export type ListManifestsResponse = Message<"nexus.catalog.v1.ListManifestsResponse"> & {
  /**
   * @generated from field: string cluster_pid = 1;
   */
  clusterPid: string;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 3;
   */
  endTime?: Timestamp;

  /**
   * @generated from field: repeated nexus.catalog.v1.Manifest manifests = 4;
   */
  manifests: Manifest[];
};

/**
 * Describes the message nexus.catalog.v1.ListManifestsResponse.
 * Use `create(ListManifestsResponseSchema)` to create a new message.
 */
export const ListManifestsResponseSchema: GenMessage<ListManifestsResponse> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 3);

/**
 * A Manifest describes a Granule where a Granule is a set of data stored in object storage
 * as a Parquet file.
 *
 * A Granule is:
 * - A Parquet file stored in object storage (e.g S3)
 * - Immutable once written
 * - Organized by cluster key (timestamp) for data locality
 * - Enriched with column statistics for query optimization
 *
 * The Manifest (this Granule descriptor) enables query engines to:
 * 1. Discover which files to read based on time range queries
 * 2. Skip files based on min/max statistics (predicate pushdown)
 * 3. Use bloom filters for efficient existence checks
 * 4. Understand the schema without reading the Parquet file
 *
 * RELATIONSHIP:
 * Granule (data file in S3) ← described by → Manifest (this message) ← stored in → CatalogService
 *
 * @generated from message nexus.catalog.v1.Manifest
 */
export type Manifest = Message<"nexus.catalog.v1.Manifest"> & {
  /**
   * The ID of the Manifest
   * NOTE: This should be left unset when creating a new Manifest, the control
   * plane will create the pid and set it here, as well as returning it in the response
   *
   * @generated from field: string pid = 1;
   */
  pid: string;

  /**
   * The key used to cluster the data into Granules. This determines how data
   * is partitioned and enables efficient querying by time and device.
   * Data locality: Granules with similar cluster keys are stored together,
   * which helps query engines process related data faster.
   *
   * @generated from field: nexus.catalog.v1.ClusterKey cluster_key = 2;
   */
  clusterKey?: ClusterKey;

  /**
   * Storage location(s) for the Parquet file.
   * Multiple locations can be specified for redundancy/multi-region support.
   *
   * @generated from field: repeated nexus.catalog.v1.StorageLocation locations = 3;
   */
  locations: StorageLocation[];

  /**
   * Physical size in bytes of the Parquet file in object storage
   *
   * @generated from field: uint64 size = 4;
   */
  size: bigint;

  /**
   * Total number of rows in the Parquet file
   *
   * @generated from field: uint64 row_count = 5;
   */
  rowCount: bigint;

  /**
   * Timestamp when the Granule was created and written to object storage
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  /**
   * Schema and statistics for each column in the Parquet file.
   * Key: column name, Value: column metadata
   * This enables query optimization without reading the actual file:
   * - Type information for schema validation
   * - Min/max values for predicate pushdown
   * - Bloom filters for existence checks
   *
   * @generated from field: map<string, nexus.catalog.v1.Column> columns = 7;
   */
  columns: { [key: string]: Column };
};

/**
 * Describes the message nexus.catalog.v1.Manifest.
 * Use `create(ManifestSchema)` to create a new message.
 */
export const ManifestSchema: GenMessage<Manifest> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 4);

/**
 * @generated from message nexus.catalog.v1.Column
 */
export type Column = Message<"nexus.catalog.v1.Column"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: nexus.catalog.v1.Statistics statistics = 2;
   */
  statistics?: Statistics;

  /**
   * @generated from field: nexus.catalog.v1.ColumnType type = 3;
   */
  type: ColumnType;
};

/**
 * Describes the message nexus.catalog.v1.Column.
 * Use `create(ColumnSchema)` to create a new message.
 */
export const ColumnSchema: GenMessage<Column> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 5);

/**
 * StorageLocation specifies where a Parquet file is stored.
 * Supports multiple storage backends for flexibility across cloud providers and local development.
 *
 * @generated from message nexus.catalog.v1.StorageLocation
 */
export type StorageLocation = Message<"nexus.catalog.v1.StorageLocation"> & {
  /**
   * @generated from oneof nexus.catalog.v1.StorageLocation.location
   */
  location: {
    /**
     * AWS S3, GCS, MinIO, Ceph, etc.
     *
     * @generated from field: nexus.catalog.v1.S3CompatibleStorage s3_compatible = 1;
     */
    value: S3CompatibleStorage;
    case: "s3Compatible";
  } | {
    /**
     * Microsoft Azure Blob Storage
     *
     * @generated from field: nexus.catalog.v1.AzureBlobStorage azure_blob = 2;
     */
    value: AzureBlobStorage;
    case: "azureBlob";
  } | {
    /**
     * Local filesystem
     *
     * @generated from field: nexus.catalog.v1.LocalStorage local = 3;
     */
    value: LocalStorage;
    case: "local";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message nexus.catalog.v1.StorageLocation.
 * Use `create(StorageLocationSchema)` to create a new message.
 */
export const StorageLocationSchema: GenMessage<StorageLocation> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 6);

/**
 * S3CompatibleStorage represents object storage using the S3 API.
 * Supports AWS S3, Google Cloud Storage (GCS), R2, Ceph, and other S3-compatible services.
 *
 * @generated from message nexus.catalog.v1.S3CompatibleStorage
 */
export type S3CompatibleStorage = Message<"nexus.catalog.v1.S3CompatibleStorage"> & {
  /**
   * Endpoint URL for the object storage service.
   * Examples:
   * - AWS S3 (us-east-1): "https://s3.us-east-1.amazonaws.com" or empty for default
   * - AWS S3 (custom region): "https://s3.<region>.amazonaws.com"
   * - GCS: "https://storage.googleapis.com"
   * - Cloudflare R2: "https://<account-id>.r2.cloudflarestorage.com"
   * If empty, defaults to AWS S3 in the region specified below.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Bucket name
   *
   * @generated from field: string bucket = 2;
   */
  bucket: string;

  /**
   * Object key/path within the bucket (e.g., "data/2024/01/flows.parquet")
   *
   * @generated from field: string key = 3;
   */
  key: string;

  /**
   * AWS region (for S3) or location (for GCS).
   * Examples: "us-east-1", "us-west-2", "eu-west-1"
   * For GCS, use GCS location names like "us-central1", "europe-west1"
   *
   * @generated from field: string region = 4;
   */
  region: string;
};

/**
 * Describes the message nexus.catalog.v1.S3CompatibleStorage.
 * Use `create(S3CompatibleStorageSchema)` to create a new message.
 */
export const S3CompatibleStorageSchema: GenMessage<S3CompatibleStorage> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 7);

/**
 * AzureBlobStorage represents Microsoft Azure Blob Storage.
 * Note: Azure Blob Storage uses a different API model than S3.
 * Uses container/blob nomenclature instead of bucket/key.
 *
 * @generated from message nexus.catalog.v1.AzureBlobStorage
 */
export type AzureBlobStorage = Message<"nexus.catalog.v1.AzureBlobStorage"> & {
  /**
   * Azure storage account name
   *
   * @generated from field: string account_name = 1;
   */
  accountName: string;

  /**
   * Container name (equivalent to S3 bucket)
   *
   * @generated from field: string container = 2;
   */
  container: string;

  /**
   * Blob name/path (equivalent to S3 key)
   *
   * @generated from field: string blob_name = 3;
   */
  blobName: string;

  /**
   * Optional: Azure endpoint suffix (e.g., "core.windows.net")
   * Defaults to "core.windows.net" if not specified.
   * Full URL format: https://{account_name}.blob.{endpoint_suffix}/{container}/{blob_name}
   *
   * @generated from field: string endpoint_suffix = 4;
   */
  endpointSuffix: string;
};

/**
 * Describes the message nexus.catalog.v1.AzureBlobStorage.
 * Use `create(AzureBlobStorageSchema)` to create a new message.
 */
export const AzureBlobStorageSchema: GenMessage<AzureBlobStorage> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 8);

/**
 * LocalStorage represents local filesystem storage.
 * Primarily used for demos, testing, and development environments.
 *
 * @generated from message nexus.catalog.v1.LocalStorage
 */
export type LocalStorage = Message<"nexus.catalog.v1.LocalStorage"> & {
  /**
   * Filesystem path (can be absolute or relative)
   * Examples:
   * - Absolute: "/data/parquet/flows.parquet"
   * - Relative: "./data/flows.parquet"
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message nexus.catalog.v1.LocalStorage.
 * Use `create(LocalStorageSchema)` to create a new message.
 */
export const LocalStorageSchema: GenMessage<LocalStorage> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 9);

/**
 * Statistics contains min/max bounds and bloom filters for a column.
 * Query engines use these statistics to determine if a Granule needs to be read:
 *
 * PREDICATE PUSHDOWN EXAMPLE:
 * Query: SELECT * FROM table WHERE age > 30
 * If a Granule's age column has max_int32 = 25, the entire file can be skipped.
 *
 * BLOOM FILTER EXAMPLE:
 * Query: SELECT * FROM table WHERE user_id = 'abc123'
 * The bloom filter can quickly indicate if 'abc123' definitely doesn't exist,
 * allowing the query engine to skip reading the file.
 *
 * @generated from message nexus.catalog.v1.Statistics
 */
export type Statistics = Message<"nexus.catalog.v1.Statistics"> & {
  /**
   * Minimum value in this column across all rows in the Granule.
   * The specific field used depends on the column type.
   *
   * @generated from oneof nexus.catalog.v1.Statistics.min
   */
  min: {
    /**
     * Handles int8, int16, int32
     *
     * @generated from field: int32 min_int32 = 1;
     */
    value: number;
    case: "minInt32";
  } | {
    /**
     * @generated from field: int64 min_int64 = 2;
     */
    value: bigint;
    case: "minInt64";
  } | {
    /**
     * Handles uint8, uint16, uint32
     *
     * @generated from field: uint32 min_uint32 = 3;
     */
    value: number;
    case: "minUint32";
  } | {
    /**
     * @generated from field: uint64 min_uint64 = 4;
     */
    value: bigint;
    case: "minUint64";
  } | {
    /**
     * @generated from field: bool min_bool = 5;
     */
    value: boolean;
    case: "minBool";
  } | {
    /**
     * @generated from field: string min_string = 6;
     */
    value: string;
    case: "minString";
  } | {
    /**
     * @generated from field: bytes min_bytes = 7;
     */
    value: Uint8Array;
    case: "minBytes";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp min_timestamp = 8;
     */
    value: Timestamp;
    case: "minTimestamp";
  } | { case: undefined; value?: undefined };

  /**
   * Maximum value in this column across all rows in the Granule.
   * The specific field used depends on the column type.
   *
   * @generated from oneof nexus.catalog.v1.Statistics.max
   */
  max: {
    /**
     * Handles int8, int16, int32
     *
     * @generated from field: int32 max_int32 = 9;
     */
    value: number;
    case: "maxInt32";
  } | {
    /**
     * @generated from field: int64 max_int64 = 10;
     */
    value: bigint;
    case: "maxInt64";
  } | {
    /**
     * Handles uint8, uint16, uint32
     *
     * @generated from field: uint32 max_uint32 = 11;
     */
    value: number;
    case: "maxUint32";
  } | {
    /**
     * @generated from field: uint64 max_uint64 = 12;
     */
    value: bigint;
    case: "maxUint64";
  } | {
    /**
     * @generated from field: bool max_bool = 13;
     */
    value: boolean;
    case: "maxBool";
  } | {
    /**
     * @generated from field: string max_string = 14;
     */
    value: string;
    case: "maxString";
  } | {
    /**
     * @generated from field: bytes max_bytes = 15;
     */
    value: Uint8Array;
    case: "maxBytes";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp max_timestamp = 16;
     */
    value: Timestamp;
    case: "maxTimestamp";
  } | { case: undefined; value?: undefined };

  /**
   * Bloom filter or similar probabilistic data structure.
   * Used for efficient "does this value exist?" queries.
   * False positives are possible, but false negatives are not.
   *
   * @generated from field: bytes filter = 17;
   */
  filter: Uint8Array;
};

/**
 * Describes the message nexus.catalog.v1.Statistics.
 * Use `create(StatisticsSchema)` to create a new message.
 */
export const StatisticsSchema: GenMessage<Statistics> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 10);

/**
 * ClusterKey defines how data is partitioned and organized into Granules.
 * The cluster key creates a partitioning scheme:
 * 1. Temporal dimension (timestamp) - enables time-range queries
 *
 * DATA LOCALITY BENEFITS:
 * - Time-range queries: "SELECT * FROM flows WHERE timestamp BETWEEN t1 AND t2"
 *   Only need to scan Granules with cluster_key.timestamp in [t1, t2]
 *
 * Granules with similar cluster keys are stored together in object storage,
 * improving cache locality and reducing the number of files that need to be read.
 *
 * @generated from message nexus.catalog.v1.ClusterKey
 */
export type ClusterKey = Message<"nexus.catalog.v1.ClusterKey"> & {
  /**
   * The timestamp when the flow was received by the system.
   * Used as the primary partitioning dimension for time-range queries.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;
};

/**
 * Describes the message nexus.catalog.v1.ClusterKey.
 * Use `create(ClusterKeySchema)` to create a new message.
 */
export const ClusterKeySchema: GenMessage<ClusterKey> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 11);

/**
 * Compaction represents metadata about a data compaction operation.
 * Compaction is the process of merging multiple small Granules into larger ones
 * to improve query performance and reduce storage overhead.
 *
 * COMPACTION LEVELS (LSM-tree style):
 * - Level 0: Initial write, many small files
 * - Level 1: First compaction pass, medium-sized files
 * - Higher levels: Further compaction, larger files with better organization
 *
 * TODO: Add metrics we care about? (e.g., rows merged, time taken, compression ratio)
 *
 * @generated from message nexus.catalog.v1.Compaction
 */
export type Compaction = Message<"nexus.catalog.v1.Compaction"> & {
  /**
   * Timestamp when the compaction operation was performed
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * The compaction level (0 = uncompacted, higher = more compacted)
   *
   * @generated from field: nexus.catalog.v1.CompactionLevel level = 2;
   */
  level: CompactionLevel;

  /**
   * The time window that was compacted
   *
   * @generated from field: nexus.catalog.v1.Window window = 3;
   */
  window?: Window;

  /**
   * Total size in bytes of the compacted output
   *
   * @generated from field: uint64 size = 4;
   */
  size: bigint;
};

/**
 * Describes the message nexus.catalog.v1.Compaction.
 * Use `create(CompactionSchema)` to create a new message.
 */
export const CompactionSchema: GenMessage<Compaction> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 12);

/**
 * Window represents a time range, typically used for compaction operations.
 * Defines the temporal boundaries of a batch of data.
 *
 * @generated from message nexus.catalog.v1.Window
 */
export type Window = Message<"nexus.catalog.v1.Window"> & {
  /**
   * Size of the window (e.g., duration in seconds or minutes)
   *
   * @generated from field: uint32 size = 1;
   */
  size: number;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 3;
   */
  endTime?: Timestamp;
};

/**
 * Describes the message nexus.catalog.v1.Window.
 * Use `create(WindowSchema)` to create a new message.
 */
export const WindowSchema: GenMessage<Window> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 13);

/**
 * Value represents a generic container for storing raw data with metadata.
 * This is used for storing arbitrary values with compression and timestamp tracking.
 * Useful for caching, intermediate results, or storing configuration data.
 *
 * @generated from message nexus.catalog.v1.Value
 */
export type Value = Message<"nexus.catalog.v1.Value"> & {
  /**
   * Timestamp when the value was first created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp when the value was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Compression algorithm applied to the raw data
   *
   * @generated from field: nexus.catalog.v1.Compression comp = 3;
   */
  comp: Compression;

  /**
   * The raw data bytes (potentially compressed)
   *
   * @generated from field: bytes raw = 4;
   */
  raw: Uint8Array;
};

/**
 * Describes the message nexus.catalog.v1.Value.
 * Use `create(ValueSchema)` to create a new message.
 */
export const ValueSchema: GenMessage<Value> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 14);

/**
 * Variant is a polymorphic value type that can hold different primitive types.
 * Similar to a union type or tagged union in programming languages.
 *
 * USE CASES:
 * - Storing heterogeneous data where the type varies at runtime
 * - Dynamic configuration values
 * - Query parameters that can be of different types
 * - Metadata values with varying types
 *
 * The oneof ensures only one field is set at a time, with the field tag
 * indicating the actual type of the stored value.
 *
 * @generated from message nexus.catalog.v1.Variant
 */
export type Variant = Message<"nexus.catalog.v1.Variant"> & {
  /**
   * @generated from oneof nexus.catalog.v1.Variant.variant
   */
  variant: {
    /**
     * @generated from field: int32 int32_variant = 1;
     */
    value: number;
    case: "int32Variant";
  } | {
    /**
     * @generated from field: int64 int64_variant = 2;
     */
    value: bigint;
    case: "int64Variant";
  } | {
    /**
     * @generated from field: uint32 uint32_variant = 3;
     */
    value: number;
    case: "uint32Variant";
  } | {
    /**
     * @generated from field: uint64 uint64_variant = 4;
     */
    value: bigint;
    case: "uint64Variant";
  } | {
    /**
     * @generated from field: bool bool_variant = 5;
     */
    value: boolean;
    case: "boolVariant";
  } | {
    /**
     * @generated from field: string string_variant = 6;
     */
    value: string;
    case: "stringVariant";
  } | {
    /**
     * @generated from field: bytes bytes_variant = 7;
     */
    value: Uint8Array;
    case: "bytesVariant";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp timestamp_variant = 8;
     */
    value: Timestamp;
    case: "timestampVariant";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message nexus.catalog.v1.Variant.
 * Use `create(VariantSchema)` to create a new message.
 */
export const VariantSchema: GenMessage<Variant> = /*@__PURE__*/
  messageDesc(file_nexus_catalog_v1_catalog, 15);

/**
 * @generated from enum nexus.catalog.v1.ColumnType
 */
export enum ColumnType {
  /**
   * @generated from enum value: COLUMN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: COLUMN_TYPE_INT8 = 1;
   */
  INT8 = 1,

  /**
   * @generated from enum value: COLUMN_TYPE_INT16 = 2;
   */
  INT16 = 2,

  /**
   * @generated from enum value: COLUMN_TYPE_INT32 = 3;
   */
  INT32 = 3,

  /**
   * @generated from enum value: COLUMN_TYPE_INT64 = 4;
   */
  INT64 = 4,

  /**
   * @generated from enum value: COLUMN_TYPE_UINT8 = 5;
   */
  UINT8 = 5,

  /**
   * @generated from enum value: COLUMN_TYPE_UINT16 = 6;
   */
  UINT16 = 6,

  /**
   * @generated from enum value: COLUMN_TYPE_UINT32 = 7;
   */
  UINT32 = 7,

  /**
   * @generated from enum value: COLUMN_TYPE_UINT64 = 8;
   */
  UINT64 = 8,

  /**
   * @generated from enum value: COLUMN_TYPE_STRING = 9;
   */
  STRING = 9,

  /**
   * @generated from enum value: COLUMN_TYPE_BOOLEAN = 10;
   */
  BOOLEAN = 10,

  /**
   * @generated from enum value: COLUMN_TYPE_TIMESTAMP = 11;
   */
  TIMESTAMP = 11,

  /**
   * @generated from enum value: COLUMN_TYPE_BYTES = 12;
   */
  BYTES = 12,
}

/**
 * Describes the enum nexus.catalog.v1.ColumnType.
 */
export const ColumnTypeSchema: GenEnum<ColumnType> = /*@__PURE__*/
  enumDesc(file_nexus_catalog_v1_catalog, 0);

/**
 * CompactionLevel indicates how many times data has been compacted.
 * Higher levels generally mean larger files with better organization.
 *
 * @generated from enum nexus.catalog.v1.CompactionLevel
 */
export enum CompactionLevel {
  /**
   * @generated from enum value: COMPACTION_LEVEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Initial write, no compaction
   *
   * @generated from enum value: COMPACTION_LEVEL_ZERO = 1;
   */
  ZERO = 1,

  /**
   * First compaction pass
   *
   * @generated from enum value: COMPACTION_LEVEL_ONE = 2;
   */
  ONE = 2,
}

/**
 * Describes the enum nexus.catalog.v1.CompactionLevel.
 */
export const CompactionLevelSchema: GenEnum<CompactionLevel> = /*@__PURE__*/
  enumDesc(file_nexus_catalog_v1_catalog, 1);

/**
 * Compression algorithms supported for compressing raw data.
 * Different algorithms offer different trade-offs between compression ratio and speed.
 *
 * @generated from enum nexus.catalog.v1.Compression
 */
export enum Compression {
  /**
   * @generated from enum value: COMPRESSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Zstandard: High compression ratio, good speed
   *
   * @generated from enum value: COMPRESSION_ZSTD = 1;
   */
  ZSTD = 1,

  /**
   * LZ4: Very fast, moderate compression
   *
   * @generated from enum value: COMPRESSION_LZ4 = 2;
   */
  LZ4 = 2,

  /**
   * Snappy: Fast, moderate compression, widely used in Parquet
   *
   * @generated from enum value: COMPRESSION_SNAPPY = 3;
   */
  SNAPPY = 3,
}

/**
 * Describes the enum nexus.catalog.v1.Compression.
 */
export const CompressionSchema: GenEnum<Compression> = /*@__PURE__*/
  enumDesc(file_nexus_catalog_v1_catalog, 2);

/**
 * CatalogService is responsible for managing the catalog store, which maintains
 * metadata about data stored in object storage.
 *
 * HIERARCHY OF ELEMENTS:
 * ----------------------
 * Organization → Team → Cluster → Manifest (Granule)
 *
 * A Granule is a set of data stored in object storage as a Parquet file.
 * A Manifest is a descriptor of a Granule, containing:
 *   - Physical metadata (size, row count, location)
 *   - Temporal metadata (cluster key with timestamp and device_id)
 *   - Column metadata (schema, statistics, bloom filters)
 *
 * The CatalogService stores all Manifests, enabling efficient query planning
 * by providing min/max statistics and bloom filters for each column, allowing
 * query engines to skip irrelevant Granules without reading the actual data files.
 *
 * DATA FLOW:
 * 1. Data is ingested and written as Parquet files (Granules) to object storage
 * 2. CreateManifest is called to register the Granule's metadata in the catalog
 * 3. Query engines use ListManifests to discover relevant Granules for a query
 * 4. Statistics and filters enable predicate pushdown and partition pruning
 *
 * @generated from service nexus.catalog.v1.CatalogService
 */
export const CatalogService: GenService<{
  /**
   * CreateManifest registers a new Granule (data file) in the catalog.
   * This should be called after successfully writing a Parquet file to object storage.
   *
   * @generated from rpc nexus.catalog.v1.CatalogService.CreateManifest
   */
  createManifest: {
    methodKind: "unary";
    input: typeof CreateManifestRequestSchema;
    output: typeof CreateManifestResponseSchema;
  },
  /**
   * ListManifests retrieves Granule descriptors for a given time range and scope.
   * Used by query engines to discover which data files need to be read.
   *
   * @generated from rpc nexus.catalog.v1.CatalogService.ListManifests
   */
  listManifests: {
    methodKind: "unary";
    input: typeof ListManifestsRequestSchema;
    output: typeof ListManifestsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_nexus_catalog_v1_catalog, 0);

